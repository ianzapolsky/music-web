<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Music Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #header {
            background: #2d2d2d;
            padding: 20px;
            text-align: center;
        }
        
        #graph-container {
            flex: 1;
            background: #1a1a1a;
        }
        
        svg {
            width: 100%;
            height: 100%;
            background: #1a1a1a;
        }
        
        .node circle {
            stroke: #ffffff;
            stroke-width: 2px;
        }
        
        .node.artist circle {
            fill: #2c3e50;
        }
        
        .node.album circle {
            fill: #8e44ad;
        }
        
        .node text {
            fill: #ffffff;
            font-size: 12px;
            text-anchor: middle;
            dominant-baseline: central;
        }
        
        .link {
            stroke-width: 2px;
            fill: none;
        }
        
        .link.artist-album {
            stroke: #4a90e2; /* Blue for artist-album relationships */
        }
        
        .link.samples {
            stroke: #8e44ad; /* Purple for sampling relationships */
        }
        
        .link.covers {
            stroke: #27ae60; /* Green for cover relationships */
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>Ian's Music Graph</h1>
        </div>
        <div id="graph-container">
            <svg id="graph-svg"></svg>
        </div>
    </div>

    <script>
        // Simple Parser for MusicDB structure
        class MusicDBParser {
            constructor() {
                this.nodes = new Map();
                this.links = [];
                this.linkSet = new Set(); // To track unique links
            }

            parseFile(content, filename) {
                // Extract node name from filename (remove .md extension and decode URL encoding)
                const nodeName = decodeURIComponent(filename.replace('.md', ''));
                
                // Determine if this is an album or artist based on content
                const isAlbum = content.includes('Artists') || content.includes('Samples');
                
                console.log(`Parsing file: ${filename}, nodeName: ${nodeName}, isAlbum: ${isAlbum}`);
                
                // Only create node if it doesn't already exist
                if (!this.nodes.has(nodeName)) {
                    this.nodes.set(nodeName, {
                        id: nodeName,
                        name: nodeName,
                        type: isAlbum ? 'album' : 'artist'
                    });
                    console.log(`Created node: ${nodeName} (${isAlbum ? 'album' : 'artist'})`);
                } else {
                    console.log(`Node already exists: ${nodeName}`);
                }
                
                // Parse Artists section
                this.parseArtists(content, nodeName);
                
                // Parse Samples section
                this.parseSamples(content, nodeName);
            }

            parseArtists(content, albumName) {
                const artistsMatch = content.match(/Artists\s*\n((?:- \[\[.*?\]\].*\n?)*)/);
                if (artistsMatch) {
                    const artistsText = artistsMatch[1];
                    const artistLines = artistsText.split('\n').filter(line => line.trim().startsWith('-'));
                    
                    artistLines.forEach(line => {
                        // Extract artist name from [[Artist Name]] format
                        const artistMatch = line.match(/\[\[([^\]]+)\]\]/);
                        if (artistMatch) {
                            const artistName = artistMatch[1];
                            
                            // Create artist node if it doesn't exist
                            if (!this.nodes.has(artistName)) {
                                this.nodes.set(artistName, {
                                    id: artistName,
                                    name: artistName,
                                    type: 'artist'
                                });
                                console.log(`Created referenced artist node: ${artistName}`);
                            } else {
                                console.log(`Referenced artist node already exists: ${artistName}`);
                            }
                            
                            // Create link from album to artist (avoid duplicates)
                            const linkKey = `${albumName}->${artistName}:artist-album`;
                            if (!this.linkSet.has(linkKey)) {
                                this.linkSet.add(linkKey);
                                this.links.push({
                                    source: albumName,
                                    target: artistName,
                                    type: 'artist-album'
                                });
                            }
                        }
                    });
                }
            }

            parseSamples(content, albumName) {
                const samplesMatch = content.match(/Samples\s*\n((?:- \[\[.*?\]\].*\n?)*)/);
                if (samplesMatch) {
                    const samplesText = samplesMatch[1];
                    const sampleLines = samplesText.split('\n').filter(line => line.trim().startsWith('-'));
                    
                    sampleLines.forEach(line => {
                        // Extract album name from [[Album Name]] format
                        const albumMatch = line.match(/\[\[([^\]]+)\]\]/);
                        if (albumMatch) {
                            const sampleAlbumName = albumMatch[1];
                            
                            // Create album node if it doesn't exist
                            if (!this.nodes.has(sampleAlbumName)) {
                                this.nodes.set(sampleAlbumName, {
                                    id: sampleAlbumName,
                                    name: sampleAlbumName,
                                    type: 'album'
                                });
                                console.log(`Created referenced album node: ${sampleAlbumName}`);
                            } else {
                                console.log(`Referenced album node already exists: ${sampleAlbumName}`);
                            }
                            
                            // Create link from album to sampled album (avoid duplicates)
                            const linkKey = `${albumName}->${sampleAlbumName}:samples`;
                            if (!this.linkSet.has(linkKey)) {
                                this.linkSet.add(linkKey);
                                this.links.push({
                                    source: albumName,
                                    target: sampleAlbumName,
                                    type: 'samples'
                                });
                            }
                        }
                    });
                }
            }

            getData() {
                const data = {
                    nodes: Array.from(this.nodes.values()),
                    links: this.links
                };
                console.log('Parser results:', {
                    nodeCount: data.nodes.length,
                    linkCount: data.links.length,
                    nodes: data.nodes.map(n => ({ id: n.id, type: n.type })),
                    links: data.links.map(l => ({ source: l.source, target: l.target, type: l.type }))
                });
                return data;
            }
        }

        // Load data from MusicDB folder
        async function loadMusicData() {
            const parser = new MusicDBParser();
            
            try {
                // Fetch the list of .md files from the /data/ directory
                const response = await fetch('/data/');
                if (!response.ok) {
                    throw new Error('Failed to fetch directory listing');
                }
                const html = await response.text();
                // Parse the HTML directory listing to extract .md filenames
                const mdFiles = [];
                // Create a temporary DOM to parse the directory listing
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;
                // Look for <a> tags that end with .md
                tempDiv.querySelectorAll('a').forEach(link => {
                    const href = link.getAttribute('href');
                    if (href && href.match(/\.md$/i)) {
                        // Remove leading slashes if present
                        const filename = href.replace(/^\/+/, '');
                        mdFiles.push(filename);
                    }
                });

                for (const filename of mdFiles) {
                    try {
                        const fileResponse = await fetch(`/data/${filename}`);
                        if (fileResponse.ok) {
                            const content = await fileResponse.text();
                            parser.parseFile(content, filename);
                        } else {
                            console.log(`File not found: ${filename}`);
                        }
                    } catch (error) {
                        console.log(`Error loading ${filename}:`, error);
                    }
                }
                
                return parser.getData();
            } catch (error) {
                console.error('Error loading music data:', error);
                // Fallback to hardcoded data
                return {
                    nodes: [],
                    links: []
                };
            }
        }


        // Initialize the graph
        async function initializeGraph() {
            // Get SVG and container
            const container = d3.select('#graph-container');
            const svg = d3.select('#graph-svg');
            
            function updateDimensions() {
                const rect = container.node().getBoundingClientRect();
                svg.attr('width', rect.width).attr('height', rect.height);
                return { width: rect.width, height: rect.height };
            }

            const { width, height } = updateDimensions();
            window.addEventListener('resize', updateDimensions);

            // Create main group
            const g = svg.append('g');

            // Load data
            const data = await loadMusicData();
            console.log('Loaded data:', data);
            
            // Check for duplicate node IDs
            const nodeIds = data.nodes.map(n => n.id);
            const uniqueNodeIds = [...new Set(nodeIds)];
            if (nodeIds.length !== uniqueNodeIds.length) {
                console.warn('Duplicate node IDs detected!', {
                    total: nodeIds.length,
                    unique: uniqueNodeIds.length,
                    duplicates: nodeIds.filter((id, index) => nodeIds.indexOf(id) !== index)
                });
            }

            // Give nodes initial random positions to prevent overlapping
            data.nodes.forEach(node => {
                node.x = Math.random() * width;
                node.y = Math.random() * height;
            });

            // Create force simulation with performance optimizations
            const simulation = d3.forceSimulation(data.nodes)
                .force('link', d3.forceLink(data.links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30))
                .alphaDecay(0.1) // Faster decay to settle quickly
                .velocityDecay(0.4) // Add some friction
                .alpha(0.5); // Start with higher energy

            // Create links
            const linkElements = g.selectAll('.link')
                .data(data.links)
                .enter()
                .append('line')
                .attr('class', d => `link ${d.type}`);

            // Create nodes
            const nodeElements = g.selectAll('.node')
                .data(data.nodes)
                .enter()
                .append('g')
                .attr('class', d => `node ${d.type}`);

            // Add circles to nodes
            nodeElements.append('circle')
                .attr('r', d => d.type === 'artist' ? 15 : 20);

            // Add text to nodes
            nodeElements.append('text')
                .attr('dy', d => d.type === 'artist' ? 25 : 30)
                .attr('text-anchor', 'middle')
                .text(d => d.name)
                .style('font-size', d => d.type === 'artist' ? '10px' : '12px');

            // Add zoom and pan behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Add drag behavior
            const drag = d3.drag()
                .on('start', (event, d) => {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                })
                .on('drag', (event, d) => {
                    d.fx = event.x;
                    d.fy = event.y;
                })
                .on('end', (event, d) => {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                });

            nodeElements.call(drag);

            // Update positions on simulation tick with performance optimization
            let animationId;
            simulation.on('tick', () => {
                if (animationId) cancelAnimationFrame(animationId);
                animationId = requestAnimationFrame(() => {
                    linkElements
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);

                    nodeElements
                        .attr('transform', d => `translate(${d.x},${d.y})`);
                });
            });

            // Stop simulation when it settles to improve performance
            simulation.on('end', () => {
                console.log('Simulation settled');
            });
        }

        // Start the application
        initializeGraph();
    </script>
</body>
</html>
